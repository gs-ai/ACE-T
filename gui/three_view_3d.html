<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACE-T Intelligence Graph - 3D Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            color: #00E5FF;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Intelligence-grade UI */
        .intel-header {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00E5FF;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            z-index: 1000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .intel-title {
            color: #00E5FF;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .intel-controls {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .control-label {
            color: #00E5FF;
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .control-input {
            background: rgba(0, 229, 255, 0.1);
            border: 1px solid #00E5FF;
            color: #00E5FF;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 11px;
            min-width: 80px;
        }

        .control-input:focus {
            outline: none;
            box-shadow: 0 0 5px #00E5FF;
        }

        .intel-button {
            background: rgba(0, 229, 255, 0.1);
            border: 1px solid #00E5FF;
            color: #00E5FF;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .intel-button:hover {
            background: rgba(0, 229, 255, 0.2);
            box-shadow: 0 0 8px #00E5FF;
        }

        .intel-button.active {
            background: #00E5FF;
            color: #000000;
        }

        /* Panel for node details */
        .intel-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00E5FF;
            border-radius: 5px;
            padding: 15px;
            font-size: 11px;
            z-index: 1000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            max-height: 400px;
            overflow-y: auto;
        }

        .panel-title {
            color: #00E5FF;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 10px;
            border-bottom: 1px solid #00E5FF;
            padding-bottom: 5px;
        }

        .panel-content {
            color: #FFFFFF;
        }

        .panel-field {
            margin-bottom: 8px;
        }

        .field-label {
            color: #00E5FF;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 9px;
        }

        .field-value {
            color: #FFFFFF;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        /* make long labels wrap and preserve line breaks */
        .field-value.label {
            white-space: pre-wrap;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .field-links {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .field-link {
            color: #00E5FF;
            text-decoration: none;
        }

        .field-link:hover {
            text-decoration: underline;
        }

        /* Legend */
        .intel-legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00E5FF;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 10px;
            z-index: 1000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            width: 240px;
            min-width: 200px;
            max-width: 45vw;
            overflow: hidden;
        }

        .intel-legend summary {
            list-style: none;
            cursor: pointer;
            color: #00E5FF;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 4px 2px 6px 2px;
            border-bottom: 1px solid rgba(0, 229, 255, 0.45);
        }

        .intel-legend summary::-webkit-details-marker {
            display: none;
        }

        .legend-caret {
            font-size: 11px;
            transition: transform 160ms ease;
        }

        .intel-legend[open] .legend-caret {
            transform: rotate(180deg);
        }

        .legend-list {
            margin-top: 8px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            padding-right: 4px;
        }

        .legend-item {
            display: grid;
            grid-template-columns: 12px minmax(0, 1fr) auto;
            align-items: center;
            margin-bottom: 6px;
            padding: 6px;
            border-radius: 6px;
            transition: background 140ms ease, transform 140ms ease;
            column-gap: 8px;
        }

        .legend-item.inactive { opacity: 0.28; transform: translateY(0px); }
        .legend-item:hover { background: rgba(0,229,255,0.02); transform: translateY(-2px); cursor: pointer; }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.04);
        }

        .legend-label {
            color: #FFFFFF;
            text-transform: uppercase;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.06em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .legend-count {
            min-width: 34px;
            text-align: right;
            color: rgba(255,255,255,0.62);
            font-weight: 700;
            letter-spacing: 0.04em;
        }

        .legend-resizer {
            position: absolute;
            left: -6px;
            top: 0;
            width: 12px;
            height: 100%;
            cursor: ew-resize;
            z-index: 1001;
        }

        /* Status indicators */
        .status-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00E5FF;
            border-radius: 5px;
            padding: 8px;
            font-size: 10px;
            z-index: 1000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .status-text {
            color: #00E5FF;
            text-transform: uppercase;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .loading-text {
            color: #00E5FF;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Hide elements initially */
        .intel-panel, .intel-legend, .status-indicator {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="three-canvas"></canvas>

        <!-- Intelligence Header -->
        <div class="intel-header">
            <div class="intel-title">ACE-T Intelligence Graph</div>
            <div class="intel-controls">
                <div class="control-group">
                    <label class="control-label">Severity</label>
                    <select id="severity-filter" class="control-input" title="Filter nodes by severity level">
                        <option value="all">All</option>
                        <option value="critical">Critical</option>
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Time Window</label>
                    <select id="time-filter" class="control-input" title="Filter nodes by time window">
                        <option value="all">All Data</option>
                        <option value="1d">Last 24h</option>
                        <option value="7d">Last 7d</option>
                        <option value="30d">Last 30d</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Search</label>
                    <input type="text" id="search-input" class="control-input" placeholder="Search nodes...">
                </div>
                <button id="fit-button" class="intel-button">Fit View</button>
                <button id="spin-button" class="intel-button active">Auto Spin</button>
                <button id="reset-button" class="intel-button">Reset</button>
            </div>
        </div>

        <!-- Node Details Panel -->
        <div class="intel-panel" id="node-panel">
            <div class="panel-title">Node Details</div>
            <div class="panel-content" id="panel-content">
                <div class="panel-field">
                    <div class="field-label">Status</div>
                    <div class="field-value">Click a node to view details</div>
                </div>
            </div>
        </div>

        <!-- Legend -->
        <details class="intel-legend" id="legend">
            <summary>
                Sources
                <span class="legend-caret">â–¾</span>
            </summary>
            <div class="legend-resizer" id="legend-resizer" title="Drag to resize"></div>
            <div class="legend-list" id="legend-content"></div>
        </details>

        <!-- Status Indicator -->
        <div class="status-indicator">
            <div class="status-text" id="status-text">Initializing...</div>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loading-overlay">
            <div class="loading-text">Loading Intelligence Data...</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from '/three/three.module.js';
        import { OrbitControls } from '/three/controls/OrbitControls.js';

        // Intelligence Graph Configuration
        const CONFIG = {
            backgroundColor: 0x000000,
            nodeColor: 0x00E5FF,
            edgeColor: 0x00E5FF,
            nodeOpacity: 0.78,
            depthBoost: 3.1,
            depthJitter: 90.0,
            surveillanceColors: {
                low: 0xFFB347,    // Amber
                moderate: 0x00D0FF, // Cyan
                high: 0xFF3B7A   // Magenta
            },
            zPlanes: {
                temporal: -100,
                confidence: 0,
                source: 100
            },
            crystalGeometry: {
                // Restore larger crystal size for better visibility
                radius: 14.0,
                detail: 2
            },
            animation: {
                pulseSpeed: 2.0,
                rotationSpeed: 0.0028,
                surveillancePulseMultiplier: 1.5
            }
        };

        class IntelligenceGraph3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.nodes = [];
                this.edges = [];
                this.nodeMeshes = [];
                this.edgeLines = [];
                this.selectedNode = null;
                this.autoSpin = true;
                this.clock = new THREE.Clock();
                this.pollHandle = null;
                this.nodeState = new Map();
                this.edgeState = [];
                this.nodeMeshesById = {};
                this.dragging = null;
                this.dragMoved = false;
                this.autoSpinBeforeDrag = null;
                this.physics = {
                    enabled: true,
                    springK: 0.0022,
                    tetherK: 0.0028,
                    damping: 0.84,
                    maxVelocity: 3.2,
                    dragStrength: 0.55,
                    dragDirect: 0.18
                };

                this.init();
                this.setupEventListeners();
                // Fetch canonical source defs first so legend can include all sources (even with 0 count)
                this.fetchSourceDefs().then(() => this.loadData());
                this.animate();
            }

            async fetchSourceDefs() {
                try {
                    const resp = await fetch('/sources');
                    const j = await resp.json();
                    this.sourceDefs = {};
                    (j.sources || []).forEach(s => { this.sourceDefs[s.name] = s.color; });
                    // Active set initially includes all known sources
                    this.activeSources = new Set(Object.keys(this.sourceDefs));
                } catch (e) {
                    this.sourceDefs = {};
                    this.activeSources = new Set();
                }
            }

            getSourceKey(node) {
                if (!node) return '';
                const sub = (node.subsource || '').trim();
                return (sub || (node.source || '')).trim().toLowerCase();
            }

            getBlendTarget(node) {
                const baseKey = this.getSourceKey(node);
                const counts = (this.adjacency && node && node.id) ? (this.adjacency[node.id] || {}) : {};
                let topKey = null;
                let topCount = 0;
                let total = 0;
                Object.keys(counts).forEach(key => {
                    const count = counts[key] || 0;
                    total += count;
                    if (key && key !== baseKey && count > topCount) {
                        topKey = key;
                        topCount = count;
                    }
                });
                if (!topKey || topCount <= 0) return null;
                const strength = Math.min(0.65, topCount / Math.max(1, total));
                return { key: topKey, strength };
            }

            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.backgroundColor);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    4000
                );
                this.camera.position.set(0, 0, 420);

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('three-canvas'),
                    antialias: true,
                    alpha: false
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Controls setup
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enablePan = true;
                this.controls.enableZoom = true;
                this.controls.enableRotate = true;

                // Lighting setup
                this.setupLighting();

                // Show UI
                this.showUI();
            }

            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);

                // Key light
                const keyLight = new THREE.DirectionalLight(0x00E5FF, 0.8);
                keyLight.position.set(100, 100, 50);
                keyLight.castShadow = true;
                keyLight.shadow.mapSize.width = 2048;
                keyLight.shadow.mapSize.height = 2048;
                this.scene.add(keyLight);

                // Fill light
                const fillLight = new THREE.DirectionalLight(0x0080FF, 0.4);
                fillLight.position.set(-100, -100, -50);
                this.scene.add(fillLight);

                // Rim light
                const rimLight = new THREE.DirectionalLight(0x00FFFF, 0.6);
                rimLight.position.set(0, 0, 100);
                this.scene.add(rimLight);
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Mouse events
                this.renderer.domElement.addEventListener('click', (event) => {
                    this.handleNodeClick(event);
                });
                this.renderer.domElement.addEventListener('pointerdown', (event) => {
                    this.handlePointerDown(event);
                });
                window.addEventListener('pointermove', (event) => {
                    this.handlePointerMove(event);
                });
                window.addEventListener('pointerup', () => {
                    this.handlePointerUp();
                });

                // Control buttons
                document.getElementById('fit-button').addEventListener('click', () => {
                    this.fitCameraToNodes();
                });

                document.getElementById('spin-button').addEventListener('click', () => {
                    this.toggleAutoSpin();
                });

                document.getElementById('reset-button').addEventListener('click', () => {
                    this.resetView();
                });

                // Filters
                document.getElementById('severity-filter').addEventListener('change', () => {
                    this.applyFilters();
                });

                document.getElementById('time-filter').addEventListener('change', () => {
                    this.applyFilters();
                });

                document.getElementById('search-input').addEventListener('input', (e) => {
                    this.searchNodes(e.target.value);
                });

                // Legend resize handle
                const legend = document.getElementById('legend');
                const resizer = document.getElementById('legend-resizer');
                if (legend && resizer) {
                    let resizing = false;
                    let startX = 0;
                    let startWidth = 0;
                    const minWidth = 200;
                    const maxWidth = Math.max(260, Math.floor(window.innerWidth * 0.45));

                    const onMouseMove = (e) => {
                        if (!resizing) return;
                        const delta = startX - e.clientX;
                        const next = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));
                        legend.style.width = `${next}px`;
                    };

                    const onMouseUp = () => {
                        if (!resizing) return;
                        resizing = false;
                        document.body.style.cursor = '';
                    };

                    resizer.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        resizing = true;
                        startX = e.clientX;
                        startWidth = legend.getBoundingClientRect().width;
                        document.body.style.cursor = 'ew-resize';
                    });

                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                }
            }

            async loadData() {
                try {
                    this.updateStatus('Fetching intelligence data...');
                    console.log('[3D] Fetching /graph_3d.json');

                    // Prefer the 3D precomputed payload when available so positions/hubs are preserved
                    const response = await fetch('/graph_3d.json');
                    console.log('[3D] Fetch response', response.status, response.statusText);

                    if (!response.ok) {
                        const txt = await response.text().catch(() => '<no-body>');
                        console.error('[3D] Non-OK response from /graph_3d.json', response.status, txt);
                        this.updateStatus(`Server error: ${response.status}`);
                        return;
                    }

                    const data = await response.json();
                    console.log('[3D] Received data', { nodes: (data.nodes || []).length, edges: (data.edges || []).length });

                    this.nodes = data.nodes || [];
                    this.edges = data.edges || [];

                    this.updateStatus(`Loaded ${this.nodes.length} nodes, ${this.edges.length} connections`);

                    // prefer built_at header when server strips meta payload
                    const hdrBuilt = parseInt(response.headers.get('X-Graph-Built-At') || '0') || null;

                    // fallback: fetch explicit meta endpoint to get built_at if header/payload lacks it
                    if (hdrBuilt) {
                        this.builtAt = hdrBuilt;
                    } else {
                        try {
                            const metaResp = await fetch('/graph_3d/meta');
                            if (metaResp.ok) {
                                const metaJson = await metaResp.json();
                                this.builtAt = metaJson.meta && metaJson.meta.built_at ? metaJson.meta.built_at : null;
                            } else {
                                console.warn('[3D] /graph_3d/meta returned', metaResp.status);
                                this.builtAt = (data.meta && data.meta.built_at) ? data.meta.built_at : null;
                            }
                        } catch (e) {
                            console.warn('[3D] Failed to fetch /graph_3d/meta', e);
                            this.builtAt = (data.meta && data.meta.built_at) ? data.meta.built_at : null;
                        }
                    }

                    this.processData();
                    this.createVisualization();
                    this.fitCameraToNodes();

                    // Hide loading overlay
                    document.getElementById('loading-overlay').style.display = 'none';

                    // Start polling for updates if not already
                    if (!this.pollHandle) {
                        this.pollHandle = setInterval(() => this.pollData(), 5000);
                    }

                    // Update legend using fetched source defs (ensures all sources visible)
                    this.updateLegend();

                } catch (error) {
                    console.error('[3D] Failed to load graph data:', error);
                    this.updateStatus(`Failed to load data: ${error && error.message ? error.message : 'unknown'}`);
                }
            }

            async pollData() {
                try {
                    // Poll the 3D payload so we pick up computed layout changes
                    const resp = await fetch('/graph_3d.json');
                    console.log('[3D] Poll response', resp.status);
                    if (!resp.ok) {
                        console.warn('[3D] Poll: non-OK response', resp.status);
                        return;
                    }
                    const data = await resp.json();
                    const hdrBuilt = parseInt(resp.headers.get('X-Graph-Built-At') || '0') || null;
                    let newBuiltAt = hdrBuilt ? hdrBuilt : ((data.meta && data.meta.built_at) ? data.meta.built_at : null);
                    if (!newBuiltAt) {
                        try {
                            const metaResp = await fetch('/graph_3d/meta');
                            if (metaResp.ok) {
                                const metaJson = await metaResp.json();
                                newBuiltAt = metaJson.meta && metaJson.meta.built_at ? metaJson.meta.built_at : null;
                            }
                        } catch (e) {
                            console.warn('[3D] Poll: failed to fetch meta', e);
                        }
                    }
                    const newNodeCount = (data.nodes || []).length;
                    const newEdgeCount = (data.edges || []).length;

                    // Update if the exporter reports a new build timestamp OR node/edge counts changed
                    if (newBuiltAt !== this.builtAt || newNodeCount !== this.nodes.length || newEdgeCount !== this.edges.length) {
                        console.log('[3D] Detected graph change - updating visualization');
                        this.nodes = data.nodes || [];
                        this.edges = data.edges || [];
                        this.builtAt = newBuiltAt;
                        this.processData();
                        this.createVisualization();
                        this.updateStatus(`Updated ${this.nodes.length} nodes, ${this.edges.length} edges`);
                    }
                    // Always refresh the legend order/counts without reloading the whole page
                    this.updateLegend();
                } catch (e) {
                    console.warn('[3D] Poll failed', e);
                }
            }



            processData() {
                // Assign Z-planes based on data attributes, but preserve exported z if present
                this.nodes.forEach(node => {
                    // If exporter provided a z coordinate, keep it
                    if (node.z !== undefined && node.z !== null) {
                        // preserve existing node.z
                    } else {
                        // Temporal plane (based on timestamp)
                        if (node.timestamp) {
                            const age = Date.now() / 1000 - node.timestamp;
                            const ageDays = age / (24 * 60 * 60);
                            node.z = CONFIG.zPlanes.temporal + (ageDays * 10); // Spread over time
                        }
                        // Confidence plane
                        else if (node.confidence !== undefined) {
                            node.z = CONFIG.zPlanes.confidence + (node.confidence * 50);
                        }
                        // Source plane
                        else {
                            node.z = CONFIG.zPlanes.source;
                        }
                    }

                    // Ensure coordinates exist
                    node.x = node.x || (Math.random() - 0.5) * 400;
                    node.y = node.y || (Math.random() - 0.5) * 400;
                    node.z = (node.z !== undefined && node.z !== null) ? node.z : 0;

                    // Boost depth so clusters read as 3D even at distance
                    const id = String(node.id || '');
                    let hash = 0;
                    for (let i = 0; i < id.length; i++) {
                        hash = ((hash << 5) - hash) + id.charCodeAt(i);
                        hash |= 0;
                    }
                    const jitter = (Math.abs(hash) % 1000) / 1000;
                    node.z = (node.z * CONFIG.depthBoost) + (CONFIG.depthJitter * (jitter - 0.5));
                });

                // Recentre nodes so auto-spin stays on a tight central axis
                if (this.nodes.length > 0) {
                    let sx = 0, sy = 0, sz = 0;
                    this.nodes.forEach(n => { sx += n.x; sy += n.y; sz += n.z; });
                    const cx = sx / this.nodes.length;
                    const cy = sy / this.nodes.length;
                    const cz = sz / this.nodes.length;
                    this.nodes.forEach(n => { n.x -= cx; n.y -= cy; n.z -= cz; });
                }
            }

            createVisualization() {
                // Clear existing meshes
                this.nodeMeshes.forEach(mesh => this.scene.remove(mesh));
                this.edgeLines.forEach(line => this.scene.remove(line));

                this.nodeMeshes = [];
                this.edgeLines = [];
                this.nodesById = {};
                this.nodes.forEach(n => { if (n && n.id) this.nodesById[n.id] = n; });
                this.adjacency = {};
                this.edges.forEach(edge => {
                    const sNode = this.nodesById[edge.source];
                    const tNode = this.nodesById[edge.target];
                    if (!sNode || !tNode) return;
                    const sKey = this.getSourceKey(sNode);
                    const tKey = this.getSourceKey(tNode);
                    if (sKey) {
                        this.adjacency[edge.source] = this.adjacency[edge.source] || {};
                        this.adjacency[edge.source][tKey] = (this.adjacency[edge.source][tKey] || 0) + 1;
                    }
                    if (tKey) {
                        this.adjacency[edge.target] = this.adjacency[edge.target] || {};
                        this.adjacency[edge.target][sKey] = (this.adjacency[edge.target][sKey] || 0) + 1;
                    }
                });

                // Create nodes
                this.nodes.forEach(node => {
                    const sourceKey = this.getSourceKey(node);
                    const mesh = this.createCrystalNode(node);
                    // visibility based on activeSources filter
                    mesh.visible = this.activeSources ? this.activeSources.has(sourceKey) : true;
                    mesh.userData.sourceKey = sourceKey;
                    this.nodeMeshes.push(mesh);
                    this.scene.add(mesh);
                });
                this.nodeMeshesById = {};
                this.nodeMeshes.forEach(mesh => {
                    if (mesh.userData && mesh.userData.id) {
                        this.nodeMeshesById[mesh.userData.id] = mesh;
                    }
                });

                // Create edges
                this.edges.forEach(edge => {
                    const line = this.createEdgeLine(edge);
                    if (line) {
                        // edge visible only if both endpoints' sources are active
                        const s = this.getSourceKey(this.nodes.find(n => n.id === edge.source));
                        const t = this.getSourceKey(this.nodes.find(n => n.id === edge.target));
                        const svis = this.activeSources ? this.activeSources.has(s) : true;
                        const tvis = this.activeSources ? this.activeSources.has(t) : true;
                        line.visible = svis && tvis;
                        this.edgeLines.push(line);
                        this.scene.add(line);
                    }
                });

                this.initPhysics();

                // Update legend
                this.updateLegend();
            }

            createCrystalNode(node) {
                // Crystal geometry - polished sphere for marble look
                // size/config: allow exporter-provided sizes, fall back to a slightly larger default for better visibility
                const geometry = new THREE.SphereGeometry(
                    CONFIG.crystalGeometry.radius,
                    16,
                    12
                );

                const nodeColor = this.resolveNodeColor(node);

                const blend = this.getBlendTarget(node);
                const blendColorHex = blend ? this.getSourceColor(blend.key) : nodeColor;
                const blendStrength = blend ? blend.strength : 0.0;

                // Custom shader material for crystal marble effect (enhanced specular + fresnel)
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        baseColor: { value: new THREE.Color(nodeColor) },
                        blendColor: { value: new THREE.Color(blendColorHex) },
                        blendStrength: { value: blendStrength },
                        surveillanceLevel: { value: this.getSurveillanceLevel(node) },
                        surveillanceColor: { value: new THREE.Color(this.getSurveillanceColor(node)) },
                        // make nodes pop more: higher emissive intensity
                        emissiveIntensity: { value: 0.95 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec3 vViewDir;

                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vViewDir = normalize(-vPosition);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 baseColor;
                        uniform vec3 blendColor;
                        uniform float blendStrength;
                        uniform float surveillanceLevel;
                        uniform vec3 surveillanceColor;
                        uniform float emissiveIntensity;

                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec3 vViewDir;

                        // simple pseudo-random for tiny sparkle
                        float rand(vec2 co){
                            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                        }

                        void main() {
                            // Fresnel-based rim lighting
                            float fresnel = pow(1.0 - max(0.0, dot(normalize(vNormal), normalize(vec3(0.0, 0.0, 1.0)))), 2.0);

                            // Surveillance pulsing
                            float pulse = surveillanceLevel > 0.0 ?
                                (0.85 + 0.35 * sin(time * ${CONFIG.animation.pulseSpeed} * surveillanceLevel)) : 1.0;

                            // base color mixed with surveillance tint
                            vec3 finalColor = mix(baseColor, surveillanceColor, surveillanceLevel * 0.65);
                            float blendPulse = blendStrength * (0.35 + 0.65 * sin(time * 0.6));
                            vec3 blended = mix(finalColor, blendColor, blendPulse);

                            // stronger specular highlight for polished marble
                            vec3 reflectDir = reflect(normalize(vec3(0.0, 0.0, 1.0)), normalize(vNormal));
                            float spec = pow(max(0.0, dot(reflectDir, vViewDir)), 60.0);

                            // small sparkle
                            float sparkle = pow(rand(vPosition.xy * 0.1 + time * 0.3), 2.0) * 0.14;

                            // combined glow (boost specular contribution)
                            float internalGlow = fresnel * emissiveIntensity * pulse + spec * 0.85 + sparkle * 0.8;

                            vec3 colorOut = blended * 1.05 + vec3(internalGlow) * 0.9 + (baseColor * 0.35);

                            gl_FragColor = vec4(colorOut, ${CONFIG.nodeOpacity});
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    depthTest: false
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(node.x, node.y, node.z);
                mesh.userData = node;

                // Scale based on importance but cap to keep marbles moderate-sized.
                // Increase default size for visibility; exporter-provided node.size still honoured when present.
                const defaultSize = 62; // larger marbles for readability
                const scale = Math.max(2.4, Math.min(6.0, (node.size || defaultSize) / 4.6));
                mesh.scale.setScalar(scale);
                mesh.userData.baseScale = scale;
                mesh.userData.baseEmissive = material.uniforms.emissiveIntensity.value;

                // Render nodes after edges and prefer additive blending so they pop through dense edge clouds
                mesh.renderOrder = 3;
                if (mesh.material) {
                    mesh.material.depthWrite = false;
                    mesh.material.depthTest = false;
                    mesh.material.transparent = true;
                    mesh.material.needsUpdate = true;
                }

                return mesh;  
            }

            createEdgeLine(edge) {
                const sourceNode = this.nodes.find(n => n.id === edge.source);
                const targetNode = this.nodes.find(n => n.id === edge.target);

                if (!sourceNode || !targetNode) return null;

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    sourceNode.x, sourceNode.y, sourceNode.z,
                    targetNode.x, targetNode.y, targetNode.z
                ]);

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const edgeColor = this.getEdgeColor(sourceNode, targetNode);
                let edgeOpacity = 0.28;
                if (edge && typeof edge.opacity === 'number') {
                    edgeOpacity = Math.max(0.02, Math.min(0.6, edge.opacity));
                } else if (edge && typeof edge.relation === 'string') {
                    const rel = edge.relation.toLowerCase();
                    if (rel === 'source_cluster' || rel === 'relation_cluster') {
                        edgeOpacity = 0.08;
                    }
                }
                const material = new THREE.LineBasicMaterial({
                    color: edgeColor,
                    transparent: true,
                    // thinner, dimmer connectors to keep nodes visible
                    opacity: edgeOpacity,
                });

                // Allow lines to write depth so connectors render with proper occlusion
                material.depthWrite = true;

                const line = new THREE.Line(geometry, material);
                line.userData = { sourceId: edge.source, targetId: edge.target };
                line.renderOrder = 1;
                return line;
            }

            getSurveillanceLevel(node) {
                if (node.surveillance) {
                    switch (node.activity_level) {
                        case 'high': return 3.0;
                        case 'moderate': return 2.0;
                        case 'low': return 1.0;
                        default: return 1.0;
                    }
                }
                return 0.0;
            }

            getSurveillanceColor(node) {
                if (!node.surveillance) return CONFIG.nodeColor;

                switch (node.activity_level) {
                    case 'high': return CONFIG.surveillanceColors.high;
                    case 'moderate': return CONFIG.surveillanceColors.moderate;
                    case 'low': return CONFIG.surveillanceColors.low;
                    default: return CONFIG.surveillanceColors.low;
                }
            }

            raycastNode(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);

                const visibleMeshes = this.nodeMeshes.filter(mesh => mesh && mesh.visible);
                const intersects = raycaster.intersectObjects(visibleMeshes);
                return intersects.length > 0 ? intersects[0] : null;
            }

            handlePointerDown(event) {
                const hit = this.raycastNode(event);
                if (!hit || !hit.object) return;
                const mesh = hit.object;
                if (!mesh.userData || !mesh.userData.id) return;

                const normal = new THREE.Vector3();
                this.camera.getWorldDirection(normal);
                const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, mesh.position);
                const lastPoint = new THREE.Vector3();
                if (!this._intersectPlane(event, plane, lastPoint)) {
                    return;
                }

                this.dragging = { id: mesh.userData.id, plane, lastPoint };
                this.dragMoved = false;
                this.autoSpinBeforeDrag = this.autoSpin;
                this.autoSpin = false;
                this.controls.enabled = false;
            }

            handlePointerMove(event) {
                if (!this.dragging || !this.dragging.id) return;
                const state = this.nodeState.get(this.dragging.id);
                if (!state) return;
                const nextPoint = new THREE.Vector3();
                if (!this._intersectPlane(event, this.dragging.plane, nextPoint)) {
                    return;
                }
                const delta = nextPoint.clone().sub(this.dragging.lastPoint);
                if (delta.lengthSq() < 0.0001) {
                    return;
                }
                this.dragMoved = true;
                this.dragging.lastPoint.copy(nextPoint);
                state.velocity.add(delta.multiplyScalar(this.physics.dragStrength));
                state.position.add(delta.multiplyScalar(this.physics.dragDirect));
                state.mesh.position.copy(state.position);
            }

            handlePointerUp() {
                if (this.dragging) {
                    this.dragging = null;
                    this.controls.enabled = true;
                    if (this.autoSpinBeforeDrag !== null) {
                        this.autoSpin = this.autoSpinBeforeDrag;
                        this.autoSpinBeforeDrag = null;
                    }
                }
            }

            _intersectPlane(event, plane, out) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                return raycaster.ray.intersectPlane(plane, out) ? true : false;
            }

            handleNodeClick(event) {
                if (this.dragMoved) {
                    this.dragMoved = false;
                    return;
                }
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);

                const visibleMeshes = this.nodeMeshes.filter(mesh => mesh && mesh.visible);
                const intersects = raycaster.intersectObjects(visibleMeshes);

                if (intersects.length > 0) {
                    const clickedMesh = intersects[0].object;
                    this.selectNode(clickedMesh.userData);
                } else {
                    this.deselectNode();
                }
            }

            selectNode(node) {
                this.selectedNode = node;
                this.updateNodePanel(node);

                // Stop auto-spin when selecting
                this.autoSpin = false;
                document.getElementById('spin-button').classList.remove('active');
                this.updateSelectionHighlight();
            }

            deselectNode() {
                this.selectedNode = null;
                this.updateNodePanel(null);
                this.updateSelectionHighlight();
            }

            updateSelectionHighlight() {
                const selectedId = this.selectedNode && this.selectedNode.id;
                this.nodeMeshes.forEach(mesh => {
                    const baseScale = mesh.userData.baseScale || 1.0;
                    const baseEmissive = mesh.userData.baseEmissive || 0.95;
                    const isSelected = selectedId && mesh.userData && mesh.userData.id === selectedId;
                    const scale = isSelected ? baseScale * 1.35 : baseScale;
                    mesh.scale.setScalar(scale);
                    if (mesh.material && mesh.material.uniforms && mesh.material.uniforms.emissiveIntensity) {
                        mesh.material.uniforms.emissiveIntensity.value = isSelected ? 1.35 : baseEmissive;
                    }
                });
            }

            updateNodePanel(node) {
                const panel = document.getElementById('node-panel');
                const content = document.getElementById('panel-content');

                if (!node) {
                    content.innerHTML = `
                        <div class="panel-field">
                            <div class="field-label">Status</div>
                            <div class="field-value">Click a node to view intelligence details</div>
                        </div>
                    `;
                    panel.style.display = 'none';
                    return;
                }

                panel.style.display = 'block';

                // build link elements (safe-ish, project is internal GUI)
                const links = [];
                if (node.post_url) links.push(`<a href="${node.post_url}" target="_blank" rel="noopener" class="field-link">Post Source</a>`);
                if (node.author_url) links.push(`<a href="${node.author_url}" target="_blank" rel="noopener" class="field-link">Author Profile</a>`);
                if (node.url) links.push(`<a href="${node.url}" target="_blank" rel="noopener" class="field-link">Direct Link</a>`);

                // confidence formatting: show decimal and percent when numeric
                function formatConfidence(v) {
                    if (v === undefined || v === null || v === '') return 'N/A';
                    const n = Number(v);
                    if (isNaN(n)) return String(v);
                    return `${n.toFixed(2)} (${(n * 100).toFixed(0)}%)`;
                }

                // last activity: accept several possible timestamp keys and nested payloads
                function pickTimestamp(obj) {
                    const keys = ['last_activity','last_seen','last_updated','updated_at','timestamp','detected_at','detectedAt','created_utc','created','posted_at','post_date','published_at','published','ingested_at'];
                    for (const k of keys) {
                        if (obj[k] !== undefined && obj[k] !== null && obj[k] !== '') return obj[k];
                    }
                    if (obj.payload) {
                        for (const k of keys) {
                            if (obj.payload[k] !== undefined && obj.payload[k] !== null && obj.payload[k] !== '') return obj.payload[k];
                        }
                    }
                    if (obj.meta && obj.meta.built_at) return obj.meta.built_at;
                    return null;
                }

                function prettyTime(ts) {
                    if (!ts && ts !== 0) return 'N/A';

                    // handle strings like ISO timestamps
                    if (typeof ts === 'string') {
                        const d = new Date(ts);
                        if (!isNaN(d.getTime())) {
                            const agoMs = Date.now() - d.getTime();
                            return `${d.toLocaleString()} (${formatRelative(agoMs)})`;
                        }
                        // try numeric parse
                        const n = Number(ts);
                        if (!isNaN(n)) ts = n;
                    }

                    // if numeric, assume seconds if small-ish
                    let t = Number(ts);
                    if (!isFinite(t)) return String(ts);
                    if (t > 1e12) { /* already ms */ }
                    else if (t > 1e9) { t = t * 1000; } // seconds -> ms
                    else if (t < 1e10) { t = t * 1000; } // fallback seconds

                    const d = new Date(t);
                    if (isNaN(d.getTime())) return String(ts);
                    const agoMs = Date.now() - d.getTime();
                    return `${d.toLocaleString()} (${formatRelative(agoMs)})`;
                }

                function formatRelative(agoMs) {
                    const sec = Math.floor(agoMs / 1000);
                    if (sec < 60) return `${sec}s ago`;
                    if (sec < 3600) return `${Math.floor(sec/60)}m ago`;
                    if (sec < 86400) return `${Math.floor(sec/3600)}h ago`;
                    return `${Math.floor(sec/86400)}d ago`;
                }

                const postTs = pickTimestamp(node) || null;
                const lastTs = pickTimestamp(node) || null; // same pick covers most cases; we may show both if different
                const conf = formatConfidence(node.confidence);
                const surv = node.surveillance ? (`Active${node.activity_level ? ' (' + node.activity_level + ')' : ''}`) : 'Inactive';

                // try to prefer a distinct post timestamp when available in payload
                const explicitPost = (node.payload && (node.payload.created_utc || node.payload.posted_at || node.payload.post_date)) ? (node.payload.created_utc || node.payload.posted_at || node.payload.post_date) : null;
                const postDisplay = explicitPost ? prettyTime(explicitPost) : (node.posted_at || node.created_utc || node.timestamp ? prettyTime(node.posted_at || node.created_utc || node.timestamp) : 'N/A');
                const lastDisplay = (node.last_activity || node.last_seen || node.updated_at || node.detected_at || node.meta && node.meta.built_at) ? prettyTime(pickTimestamp(node)) : 'N/A';

                content.innerHTML = `
                    <div class="panel-field">
                        <div class="field-label">ID</div>
                        <div class="field-value">${node.id}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Label</div>
                        <div class="field-value label">${(node.label || 'Unknown')}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Kind</div>
                        <div class="field-value">${node.kind || 'n/a'}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Severity</div>
                        <div class="field-value">${(node.severity || 'unknown').toUpperCase()}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Source</div>
                        <div class="field-value">${node.subsource || node.source || 'Unknown'}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Confidence</div>
                        <div class="field-value">${conf}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Posted</div>
                        <div class="field-value">${postDisplay}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Last Activity</div>
                        <div class="field-value">${lastDisplay}</div>
                    </div>
                    <div class="panel-field">
                        <div class="field-label">Surveillance</div>
                        <div class="field-value">${surv}</div>
                    </div>
                    ${links.length > 0 ? `
                    <div class="panel-field">
                        <div class="field-label">Links</div>
                        <div class="field-value field-links">${links.join('')}</div>
                    </div>
                    ` : ''}
                `;
            }

            updateLegend() {
                const legendContent = document.getElementById('legend-content');
                // Use canonical source defs so we include all known sources even with zero counts
                const known = Object.keys(this.sourceDefs || {});

                // count nodes per source
                const counts = {};
                (this.nodes || []).forEach(n => {
                    const s = this.getSourceKey(n);
                    counts[s] = (counts[s] || 0) + 1;
                });

                // Sort by count desc, then name
                known.sort((a, b) => {
                    const ca = counts[a] || 0;
                    const cb = counts[b] || 0;
                    if (cb !== ca) return cb - ca;
                    return a.localeCompare(b);
                });

                legendContent.innerHTML = known.map(source => {
                    const color = this.sourceDefs[source] || '#00E5FF';
                    const count = counts[source] || 0;
                    const active = this.activeSources && this.activeSources.has(source);
                    const cls = active ? 'legend-item' : 'legend-item inactive';
                    const label = source.toUpperCase();
                    return `
                    <div class="${cls}" data-source="${source}" style="cursor:pointer;">
                        <div class="legend-color" style="background: ${color}; border-color: ${color};"></div>
                        <div class="legend-label" title="${label}">${label}</div>
                        <div class="legend-count">(${count})</div>
                    </div>
                `
                }).join('');

                // add click handlers for interactive filtering
                Array.from(legendContent.querySelectorAll('[data-source]')).forEach(el => {
                    el.addEventListener('click', (e) => {
                        const src = el.getAttribute('data-source');
                        if (!this.activeSources) this.activeSources = new Set(Object.keys(this.sourceDefs || {}));
                        if (this.activeSources.has(src)) this.activeSources.delete(src);
                        else this.activeSources.add(src);
                        this.applyLocalFilter();
                        // toggle visual state
                        el.classList.toggle('inactive', !this.activeSources.has(src));
                    });
                });

                document.getElementById('legend').style.display = known.length > 0 ? 'block' : 'none';
            }

            getSourceColor(source) {
                // Prefer server-provided sourceDefs when available
                if (this.sourceDefs && this.sourceDefs[source]) return this.sourceDefs[source];
                const key = (source || '').toLowerCase();
                let hash = 0;
                for (let i = 0; i < key.length; i++) {
                    hash = ((hash << 5) - hash) + key.charCodeAt(i);
                    hash |= 0;
                }
                const hue = Math.abs(hash) % 360;
                const sat = 70;
                const light = 52;
                const h = hue / 360;
                const s = sat / 100;
                const l = light / 100;
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                const toHex = v => {
                    const h = Math.round(v * 255).toString(16).padStart(2, '0');
                    return h;
                };
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            resolveNodeColor(node) {
                if (!node) return CONFIG.nodeColor;
                const sourceKey = this.getSourceKey(node);
                if (this.sourceDefs && this.sourceDefs[sourceKey]) {
                    const v = this.sourceDefs[sourceKey];
                    if (typeof v === 'string') return v;
                    if (v && v.color) return v.color;
                }
                if (node.color && String(node.color).length) return node.color;
                return CONFIG.nodeColor;
            }

            getEdgeColor(sourceNode, targetNode) {
                const aKey = this.getSourceKey(sourceNode);
                const bKey = this.getSourceKey(targetNode);
                const aColor = new THREE.Color(this.resolveNodeColor(sourceNode));
                if (!bKey || aKey === bKey) {
                    return aColor;
                }
                const bColor = new THREE.Color(this.resolveNodeColor(targetNode));
                return aColor.lerp(bColor, 0.5);
            }

            fitCameraToNodes() {
                if (this.nodes.length === 0) return;

                const box = new THREE.Box3();
                this.nodeMeshes.forEach(mesh => {
                    box.expandByObject(mesh);
                });

                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                // If graph fits to a single point, use a conservative default distance so nodes are visible
                const distance = (maxDim && maxDim > 1.0) ? (maxDim * 1.5) : 220;

                this.controls.target.copy(center);
                this.camera.position.copy(center.clone().add(new THREE.Vector3(0, 0, distance)));
                this.controls.update();
            }

            toggleAutoSpin() {
                this.autoSpin = !this.autoSpin;
                document.getElementById('spin-button').classList.toggle('active', this.autoSpin);
            }

            resetView() {
                this.camera.position.set(0, 0, 300);
                this.controls.target.set(0, 0, 0);
                this.controls.update();
                this.deselectNode();
            }

            applyFilters() {
                // low-level UI filter trigger: mirror into activeSources if needed
                console.log('Applying filters...');
                this.applyLocalFilter();
            }

            searchNodes(query) {
                // Implement search logic here
                console.log('Searching for:', query);
            }

            applyLocalFilter() {
                // Apply current activeSources set to node and edge visibility
                const active = this.activeSources || new Set(Object.keys(this.sourceDefs || {}));
                this.nodeMeshes.forEach(mesh => {
                    const n = mesh.userData || {};
                    const s = this.getSourceKey(n);
                    mesh.visible = active.has(s);
                });
                this.edgeLines.forEach(line => {
                    const visibleIds = new Set(this.nodeMeshes.filter(m => m.visible).map(m => m.userData && m.userData.id));
                    if (line.userData && line.userData.sourceId && line.userData.targetId) {
                        line.visible = visibleIds.has(line.userData.sourceId) && visibleIds.has(line.userData.targetId);
                        return;
                    }
                    const pos = line.geometry.attributes.position.array;
                    // attempt to find source/target by comparing positions (fallback)
                    let a = pos.slice(0,3);
                    let b = pos.slice(3,6);
                    const approxFind = (coord) => {
                        for (const m of this.nodeMeshes) {
                            const p = m.position;
                            if (Math.abs(p.x - coord[0]) < 0.5 && Math.abs(p.y - coord[1]) < 0.5 && Math.abs(p.z - coord[2]) < 0.5) return m.userData && m.userData.id;
                        }
                        return null;
                    };
                    const sId = approxFind(a);
                    const tId = approxFind(b);
                    line.visible = sId && tId && visibleIds.has(sId) && visibleIds.has(tId);
                });
            }

            initPhysics() {
                this.nodeState = new Map();
                this.edgeState = [];
                if (!this.nodeMeshes || this.nodeMeshes.length === 0) {
                    return;
                }

                this.nodeMeshes.forEach(mesh => {
                    if (!mesh.userData || !mesh.userData.id) return;
                    const rest = mesh.position.clone();
                    const massRaw = mesh.userData.mass || 1.0;
                    const mass = 1.0 + Math.min(6.0, Math.max(0.5, massRaw / 6.0));
                    this.nodeState.set(mesh.userData.id, {
                        id: mesh.userData.id,
                        mesh,
                        position: mesh.position.clone(),
                        rest,
                        velocity: new THREE.Vector3(),
                        mass,
                    });
                });

                this.edgeLines.forEach(line => {
                    if (!line.userData || !line.userData.sourceId || !line.userData.targetId) return;
                    const srcState = this.nodeState.get(line.userData.sourceId);
                    const tgtState = this.nodeState.get(line.userData.targetId);
                    if (!srcState || !tgtState) return;
                    const restLength = srcState.rest.distanceTo(tgtState.rest);
                    this.edgeState.push({
                        line,
                        sourceId: line.userData.sourceId,
                        targetId: line.userData.targetId,
                        restLength,
                    });
                });
            }

            applyPhysics(deltaTime) {
                if (!this.physics.enabled || this.nodeState.size === 0) {
                    return;
                }
                const dt = Math.min(0.033, Math.max(0.001, deltaTime));
                const forces = new Map();
                const visibleIds = new Set(this.nodeMeshes.filter(m => m.visible).map(m => m.userData.id));

                this.nodeState.forEach((state, id) => {
                    if (!visibleIds.has(id)) return;
                    forces.set(id, new THREE.Vector3());
                });

                this.edgeState.forEach(edge => {
                    if (!edge || !edge.sourceId || !edge.targetId) return;
                    if (!visibleIds.has(edge.sourceId) || !visibleIds.has(edge.targetId)) return;
                    const a = this.nodeState.get(edge.sourceId);
                    const b = this.nodeState.get(edge.targetId);
                    if (!a || !b) return;
                    const delta = new THREE.Vector3().subVectors(b.position, a.position);
                    const dist = Math.max(0.001, delta.length());
                    const stretch = dist - edge.restLength;
                    const forceMag = stretch * this.physics.springK;
                    const dir = delta.multiplyScalar(1.0 / dist);
                    const force = dir.multiplyScalar(forceMag);
                    if (forces.has(a.id)) forces.get(a.id).add(force);
                    if (forces.has(b.id)) forces.get(b.id).addScaledVector(force, -1);
                });

                this.nodeState.forEach((state, id) => {
                    if (!visibleIds.has(id)) return;
                    const force = forces.get(id) || new THREE.Vector3();
                    const tether = new THREE.Vector3().subVectors(state.rest, state.position).multiplyScalar(this.physics.tetherK);
                    force.add(tether);
                    const invMass = 1.0 / state.mass;
                    state.velocity.addScaledVector(force, dt * invMass);
                    const damp = Math.pow(this.physics.damping, dt * 60.0);
                    state.velocity.multiplyScalar(damp);
                    if (state.velocity.length() > this.physics.maxVelocity) {
                        state.velocity.setLength(this.physics.maxVelocity);
                    }
                    state.position.addScaledVector(state.velocity, dt);
                    state.mesh.position.copy(state.position);
                    if (state.mesh.userData) {
                        state.mesh.userData.x = state.position.x;
                        state.mesh.userData.y = state.position.y;
                        state.mesh.userData.z = state.position.z;
                    }
                });
            }

            updateEdgePositions() {
                if (!this.edgeState || this.edgeState.length === 0) return;
                this.edgeState.forEach(edge => {
                    if (!edge || !edge.line || !edge.line.geometry) return;
                    if (!edge.line.visible) return;
                    const a = this.nodeState.get(edge.sourceId);
                    const b = this.nodeState.get(edge.targetId);
                    if (!a || !b) return;
                    const pos = edge.line.geometry.attributes.position.array;
                    pos[0] = a.position.x;
                    pos[1] = a.position.y;
                    pos[2] = a.position.z;
                    pos[3] = b.position.x;
                    pos[4] = b.position.y;
                    pos[5] = b.position.z;
                    edge.line.geometry.attributes.position.needsUpdate = true;
                });
            }

            updateStatus(text) {
                document.getElementById('status-text').textContent = text;
            }

            showUI() {
                document.querySelector('.intel-panel').style.display = 'none';
                document.querySelector('.intel-legend').style.display = 'block';
                document.querySelector('.status-indicator').style.display = 'block';
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const deltaTime = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                // Update node shaders
                this.nodeMeshes.forEach(mesh => {
                    if (mesh.material.uniforms) {
                        mesh.material.uniforms.time.value = time;
                    }
                });

                this.applyPhysics(deltaTime);
                this.updateEdgePositions();

                // Auto rotation
                if (this.autoSpin) {
                    this.scene.rotation.y += CONFIG.animation.rotationSpeed;
                    this.scene.rotation.x = 0;
                    this.scene.rotation.z = 0;
                }

                // Update controls
                this.controls.update();

                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the intelligence graph
        new IntelligenceGraph3D();
    </script>
</body>
</html>
